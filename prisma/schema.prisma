generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Auth Models (Better Auth)
model User {
  id            String   @id
  name          String
  email         String   @unique
  emailVerified Boolean
  image         String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  accounts     Account[]
  sessions     Session[]
  userAccounts UserAccount[]

  @@map("user")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("account")
}

model Verification {
  id         String    @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt

  @@map("verification")
}

// Core Trading Models
model UserAccount {
  id     String @id @default(uuid())
  userId String
  name   String @default("Main Account")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  exchanges Exchange[]
  positions Position[]
  orders    Order[]
  bots      Bot[]

  @@map("user_account")
}

model Exchange {
  id            String  @id @default(uuid())
  userAccountId String
  name          String  @default("Binance")
  apiKey        String // Encrypted
  apiSecret     String // Encrypted
  isActive      Boolean @default(true)

  positionMode PositionMode @default(Hedge)

  // total value
  totalValue String @default("0")

  lastSyncedAt DateTime @default(now())

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userAccount UserAccount @relation(fields: [userAccountId], references: [id], onDelete: Cascade)
  bots        Bot[]

  @@map("exchange")
}

model Position {
  id            String @id @default(uuid())
  userAccountId String

  // Core trade data
  symbol     String
  side       Side
  type       OrderOrderType
  entryPrice Float
  quantity   Float
  entryValue Float

  // Current state
  currentPrice Float?
  status       Status @default(OPEN)

  // Exit data (nullable until closed)
  exitPrice  Float?
  exitValue  Float?
  pnl        Float  @default(0)
  pnlPercent Float  @default(0)

  // Risk management
  stopLoss   Float?
  takeProfit Float?

  // Metadata
  source Source  @default(MANUAL) // MANUAL, BOT
  botId  String?

  // Strategy information
  strategyId String? // Unique strategy identifier

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userAccount UserAccount @relation(fields: [userAccountId], references: [id], onDelete: Cascade)
  bot         Bot?        @relation(fields: [botId], references: [id], onDelete: SetNull)
  orders      Order[] // Position has many orders

  @@map("position")
}

model Order {
  id            String @id @default(uuid())
  positionId    String
  userAccountId String

  // Order identification
  orderId   String // External order ID from exchange
  symbol    String
  type      OrderType      @default(ENTRY) // ENTRY, EXIT
  side      OrderSide      @default(BUY) // BUY, SELL
  orderType OrderOrderType @default(MARKET) // MARKET, LIMIT

  // Order details
  price    Float
  quantity Float
  value    Float // Total value (price * quantity)

  // Order status
  status      OrderStatus @default(NEW)
  fillPercent Float       @default(0) // Fill percentage (0-100)

  // P&L for this specific order
  pnl Float @default(0)

  // Details if invalid order like insufficient balance, etc.
  details String?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationships
  position    Position    @relation(fields: [positionId], references: [id], onDelete: Cascade)
  userAccount UserAccount @relation(fields: [userAccountId], references: [id], onDelete: Cascade)

  @@map("order")
}

model Bot {
  id            String  @id @default(uuid())
  userAccountId String
  exchangeId    String
  name          String
  isActive      Boolean @default(true)

  // Simple settings
  symbols         String[] @default([]) // ["BTCUSDT"]
  positionPercent Float    @default(10) // % of portfolio per trade
  stopLoss        Float? // % stop loss
  takeProfit      Float? // % take profit

  // Webhook
  webhookSecret String @default(uuid())

  // Stats
  totalTrades Int   @default(0)
  winTrades   Int   @default(0)
  totalPnl    Float @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  userAccount UserAccount @relation(fields: [userAccountId], references: [id], onDelete: Cascade)
  exchange    Exchange    @relation(fields: [exchangeId], references: [id], onDelete: Cascade)
  signals     Signal[]
  positions   Position[]

  @@map("bot")
}

model Signal {
  id    String @id @default(uuid())
  botId String

  action  Action
  symbol  String
  price   Float?
  message String?

  processed Boolean  @default(false)
  error     String?
  createdAt DateTime @default(now())

  bot Bot @relation(fields: [botId], references: [id], onDelete: Cascade)

  @@map("signal")
}

enum PositionMode {
  One_Way
  Hedge
}

// Simple Enums
enum Side {
  LONG
  SHORT
}

enum Status {
  OPEN
  CLOSED
  CANCELED
  MARKET_CLOSED
  FAILED
}

enum Action {
  ENTER_LONG
  EXIT_LONG
  ENTER_SHORT
  EXIT_SHORT
}

enum Source {
  MANUAL
  BOT
}

// Order-specific Enums
enum OrderType {
  ENTRY
  EXIT
}

enum OrderSide {
  BUY
  SELL
}

enum OrderOrderType {
  MARKET
  LIMIT
}

enum OrderStatus {
  NEW
  PENDING
  FILLED
  COMPLETED
  CANCELED
  REJECTED
  PARTIALLY_FILLED
}
