# Cursor Rules: Signal Bot Refactoring with Functional Programming

## Overview
This document defines the coding standards, patterns, and architectural guidelines for refactoring the signal bot system using a functional programming approach. All signal bot related code must follow these rules to ensure consistency, maintainability, and modularity.

## Core Architecture Principles

### 1. Functional Programming Approach
- **Pure Functions Only**: All business logic functions must be pure (no side effects, same output for same input)
- **Function Composition**: Use `pipe` and function composition for complex workflows
- **Single Responsibility**: Each function does one thing and does it well
- **Immutable Data**: Avoid mutating objects, prefer creating new objects with spreads
- **Currying**: Use currying for functions that can be partially applied

### 2. File Organization Structure
```
src/
├── lib/
│   └── signal-bot/
│       ├── trading-functions.ts          # Core trading utilities
│       ├── position-sizing.ts           # Position calculation functions
│       ├── balance-functions.ts         # Balance and asset functions
│       ├── position-creation.ts         # Position creation workflows
│       ├── validation-functions.ts      # Input validation functions
│       ├── error-handling.ts            # Error handling utilities
│       ├── utility-functions.ts         # General utility functions
│       └── workflows/
│           └── position-workflow.ts     # Main workflow composition
├── app/
│   ├── api/signal-bots/[id]/position/
│   │   └── route.ts                     # Refactored API endpoint
│   └── (main)/signal-bot/_components/
│       ├── dialogs/
│       │   ├── create-signal-bot-dialog.tsx
│       │   └── position-confirmation-dialog.tsx
│       ├── hooks/
│       │   ├── use-position-calculation.ts
│       │   └── use-signal-bot-data.ts
│       └── signal-bot-client.tsx
├── types/
│   └── signal-bot/
│       ├── functional.ts                # Function parameter types
│       └── validation.ts               # Validation result types
└── db/schema/
    └── signal-bot-functional.ts         # Functional programming schemas
```

## Functional Programming Patterns

### 1. Function Signatures
```typescript
// ✅ Good: Clear input/output with proper typing
export const calculatePositionSize = (
  portfolioValue: number,
  portfolioPercent: number,
  currentPrice: number,
  side: 'Long' | 'Short' = 'Long'
): number => {
  const targetValue = (portfolioValue * portfolioPercent) / 100;
  return targetValue / currentPrice;
};

// ✅ Good: Pure function with no side effects
export const validateOrderNotation = (
  symbol: string,
  quantity: number,
  symbolInfo: SymbolInfo
): ValidationResult => {
  // Pure calculation logic only
};

// ❌ Bad: Side effects in business logic
export const createPosition = async (data: any) => {
  // Don't mix DB calls with business logic
};
```

### 2. Function Composition
```typescript
// ✅ Use function composition for workflows
export const createPositionWorkflow = async (
  context: PositionCreationContext
): Promise<PositionResult> => {
  return pipe(
    validatePositionCreationContext,
    fetchTradingData,
    calculatePositionSizing,
    validatePositionConstraints,
    executePositionCreation,
    handleSuccess,
    handleError
  )(context);
};

// ✅ Implement pipe function
export const pipe = (...fns: Array<(arg: any) => any>) =>
  (value: any) => fns.reduce((acc, fn) => fn(acc), value);
```

### 3. Error Handling Pattern
```typescript
// ✅ Consistent error handling
export const handlePositionError = async (
  error: Error,
  context: ErrorContext
): Promise<ErrorResult> => {
  console.error('Position creation error:', error);

  // Cleanup logic
  if (context.positionId) {
    await cleanupFailedPosition(context.positionId);
  }

  return {
    success: false,
    error: error.message,
    errorType: determineErrorType(error),
    statusCode: getHttpStatusCode(error.errorType),
    context
  };
};
```

## Type Definitions

### 1. Core Types
```typescript
// src/types/signal-bot/functional.ts
export interface PositionCreationContext {
  bot: SignalBot;
  symbol: string;
  side: 'Long' | 'Short';
  customQuantity?: number;
  userAccountId: string;
}

export interface EnrichedContext extends PositionCreationContext {
  currentPrice: number;
  symbolInfo: SymbolInfo;
  balances: AssetBalance[];
}

export interface ValidationResult {
  isValid: boolean;
  errors: string[];
  suggestedQuantity?: number;
  data?: Record<string, any>;
}

export interface PositionResult {
  success: boolean;
  position?: Position;
  message?: string;
  error?: string;
  errorType?: ErrorType;
  statusCode?: number;
}
```

### 2. Error Types
```typescript
// src/types/signal-bot/validation.ts
export type ErrorType =
  | 'INSUFFICIENT_BALANCE'
  | 'INVALID_SYMBOL'
  | 'EXCHANGE_ERROR'
  | 'ORDER_ERROR'
  | 'VALIDATION_ERROR'
  | 'UNKNOWN_ERROR';

export interface ErrorContext {
  botId: string;
  symbol: string;
  side: 'Long' | 'Short';
  positionId?: string;
}
```

## Component Architecture

### 1. Dialog Components Pattern
```typescript
// src/app/(main)/signal-bot/_components/dialogs/position-confirmation-dialog.tsx
interface PositionConfirmationDialogProps {
  bot: SignalBot;
  open: boolean;
  onOpenChange: (open: boolean) => void;
  onSuccess: () => void;
  positionCalculator?: PositionCalculator;
}

export function PositionConfirmationDialog({
  bot,
  open,
  onOpenChange,
  onSuccess,
  positionCalculator = new PositionCalculator()
}: PositionConfirmationDialogProps) {
  const [selectedSide, setSelectedSide] = useState<'Long' | 'Short' | null>(null);
  const [calculation, setCalculation] = useState<PositionCalculation | null>(null);

  // Use custom hook for calculations
  const { calculation: liveCalculation } = usePositionCalculation(
    bot,
    bot.symbols[0],
    selectedSide
  );

  useEffect(() => {
    if (open && bot) {
      loadPositionCalculation();
    }
  }, [open, bot]);

  const handleCreatePosition = async (side: 'Long' | 'Short') => {
    try {
      setIsCreatingPosition(true);
      const result = await createPositionWorkflow({
        bot,
        symbol: bot.symbols[0],
        side,
        userAccountId: bot.userAccountId
      });

      if (result.success) {
        onSuccess();
        onOpenChange(false);
      }
    } catch (error) {
      // Error handling with user feedback
    } finally {
      setIsCreatingPosition(false);
    }
  };
}
```

### 2. Custom Hooks Pattern
```typescript
// src/app/(main)/signal-bot/_components/hooks/use-position-calculation.ts
export function usePositionCalculation(
  bot: SignalBot | null,
  symbol: string,
  side: 'Long' | 'Short' | null
) {
  const [calculation, setCalculation] = useState<PositionCalculation | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const recalculatePosition = useCallback(async () => {
    if (!bot || !symbol || !side) return;

    setIsLoading(true);
    setError(null);

    try {
      const context: PositionCreationContext = {
        bot,
        symbol,
        side,
        userAccountId: bot.userAccountId
      };

      const enrichedContext = await fetchTradingData(context);
      const calculatedContext = calculatePositionSizing(enrichedContext);

      setCalculation({
        quantity: calculatedContext.quantity,
        positionValue: calculatedContext.positionValue,
        stopLoss: calculatedContext.stopLoss,
        takeProfit: calculatedContext.takeProfit,
        validation: calculatedContext.validation
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Calculation failed');
    } finally {
      setIsLoading(false);
    }
  }, [bot, symbol, side]);

  useEffect(() => {
    recalculatePosition();
  }, [recalculatePosition]);

  return {
    calculation,
    isLoading,
    error,
    recalculate: recalculatePosition
  };
}
```

## Schema Definitions

### 1. Functional Schemas
```typescript
// src/db/schema/signal-bot-functional.ts
export const positionCreationSchema = z.object({
  botId: z.string().uuid(),
  symbol: z.string().regex(/^[A-Z]+USDT?$/, "Invalid symbol format"),
  side: z.enum(["Long", "Short"]),
  customQuantity: z.number().positive().optional(),
  userAccountId: z.string().uuid()
});

export const positionCalculationSchema = z.object({
  portfolioValue: z.number().positive(),
  portfolioPercent: z.number().min(1).max(100),
  currentPrice: z.number().positive(),
  side: z.enum(["Long", "Short"]),
  quantity: z.number().positive(),
  positionValue: z.number().positive()
});

export type PositionCreationData = z.infer<typeof positionCreationSchema>;
export type PositionCalculationData = z.infer<typeof positionCalculationSchema>;
```

## API Endpoint Patterns

### 1. Functional API Structure
```typescript
// src/app/api/signal-bots/[id]/position/route.ts
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    // 1. Authentication and authorization
    const session = await auth.api.getSession({ headers: await headers() });
    if (!session?.user?.id) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    // 2. Input validation
    const body = await request.json();
    const validatedData = positionCreationSchema.safeParse(body);

    if (!validatedData.success) {
      return NextResponse.json({
        error: "Invalid request data",
        details: validatedData.error.issues,
      }, { status: 400 });
    }

    // 3. Get required data
    const bot = await getBotWithExchange(params.id, session.user.id);
    if (!bot) {
      return NextResponse.json({ error: "Signal bot not found" }, { status: 404 });
    }

    // 4. Execute functional workflow
    const result = await createPositionWorkflow({
      bot,
      ...validatedData.data
    });

    // 5. Return structured response
    return NextResponse.json(result, {
      status: result.success ? 201 : 400
    });

  } catch (error) {
    // 6. Handle errors functionally
    const errorResult = await handlePositionError(error, {
      botId: params.id,
      symbol: 'unknown',
      side: 'Long'
    });

    return NextResponse.json(errorResult, {
      status: errorResult.statusCode || 500
    });
  }
}
```

## Testing Guidelines

### 1. Unit Testing Pattern
```typescript
// src/lib/signal-bot/__tests__/trading-functions.test.ts
describe('calculatePositionSize', () => {
  it('should calculate correct position size for long position', () => {
    const result = calculatePositionSize(10000, 20, 50000, 'Long');
    expect(result).toBe(0.004); // (10000 * 20%) / 50000
  });

  it('should handle zero portfolio value', () => {
    expect(() => calculatePositionSize(0, 20, 50000, 'Long'))
      .toThrow('Portfolio value must be positive');
  });
});

describe('validateOrderNotation', () => {
  const mockSymbolInfo: SymbolInfo = {
    minQty: 0.001,
    stepSize: 0.001,
    minNotional: 10
  };

  it('should validate correct quantity', () => {
    const result = validateOrderNotation('BTCUSDT', 0.001, mockSymbolInfo);
    expect(result.isValid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });

  it('should reject quantity below minimum', () => {
    const result = validateOrderNotation('BTCUSDT', 0.0005, mockSymbolInfo);
    expect(result.isValid).toBe(false);
    expect(result.errors).toContain('Quantity 0.0005 is below minimum 0.001 for BTCUSDT');
  });
});
```

### 2. Integration Testing Pattern
```typescript
// src/lib/signal-bot/__tests__/position-workflow.test.ts
describe('createPositionWorkflow', () => {
  it('should create position successfully with valid inputs', async () => {
    const mockContext: PositionCreationContext = {
      bot: mockBot,
      symbol: 'BTCUSDT',
      side: 'Long',
      userAccountId: 'user-123'
    };

    const result = await createPositionWorkflow(mockContext);

    expect(result.success).toBe(true);
    expect(result.position).toBeDefined();
    expect(result.position?.symbol).toBe('BTCUSDT');
    expect(result.position?.side).toBe('LONG');
  });

  it('should handle insufficient balance error', async () => {
    const mockContextWithLowBalance: PositionCreationContext = {
      bot: mockBotWithLowBalance,
      symbol: 'BTCUSDT',
      side: 'Long',
      userAccountId: 'user-123'
    };

    const result = await createPositionWorkflow(mockContextWithLowBalance);

    expect(result.success).toBe(false);
    expect(result.errorType).toBe('INSUFFICIENT_BALANCE');
    expect(result.statusCode).toBe(400);
  });
});
```

## Code Style Guidelines

### 1. Import Organization
```typescript
// ✅ Group imports logically
import { useState, useEffect, useCallback } from 'react';
import { z } from 'zod';

// Third-party libraries
import { toast } from 'sonner';
import { useMutation, useQuery } from '@tanstack/react-query';

// Internal utilities
import { calculatePositionSize } from '@/lib/signal-bot/position-sizing';
import { validateOrderNotation } from '@/lib/signal-bot/trading-functions';

// Components
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';

// Types
import type { SignalBot, PositionCreationContext } from '@/types/signal-bot';
```

### 2. Function Documentation
```typescript
/**
 * Calculate optimal position size based on portfolio percentage
 *
 * @param portfolioValue - Total portfolio value in USD
 * @param portfolioPercent - Percentage of portfolio to use (1-100)
 * @param currentPrice - Current asset price in USD
 * @param side - Position side ('Long' or 'Short')
 * @returns number - Calculated position quantity
 *
 * @example
 * ```typescript
 * const quantity = calculatePositionSize(10000, 20, 50000, 'Long');
 * // Returns: 0.004 (10000 * 20% / 50000)
 * ```
 *
 * @throws Error when portfolio value is not positive
 */
export const calculatePositionSize = (
  portfolioValue: number,
  portfolioPercent: number,
  currentPrice: number,
  side: 'Long' | 'Short' = 'Long'
): number => {
  // Implementation
};
```

### 3. Error Handling Consistency
```typescript
// ✅ Consistent error handling pattern
try {
  const result = await someOperation();
  return { success: true, data: result };
} catch (error) {
  const errorResult = await handleOperationError(error, context);
  return {
    success: false,
    error: errorResult.message,
    errorType: errorResult.errorType,
    statusCode: errorResult.statusCode
  };
}
```

## Performance Guidelines

### 1. Memoization for Expensive Calculations
```typescript
// ✅ Use memoization for expensive calculations
import memoize from 'lodash/memoize';

export const calculatePositionSize = memoize(
  (portfolioValue: number, portfolioPercent: number, currentPrice: number): number => {
    const targetValue = (portfolioValue * portfolioPercent) / 100;
    return targetValue / currentPrice;
  },
  (portfolioValue, portfolioPercent, currentPrice) =>
    `${portfolioValue}-${portfolioPercent}-${currentPrice}`
);
```

### 2. React Hook Optimization
```typescript
// ✅ Optimize hooks with proper dependencies
const { calculation, isLoading, error } = usePositionCalculation(
  bot,
  symbol,
  selectedSide
);

useEffect(() => {
  // Only recalculate when necessary
  if (bot && symbol && selectedSide) {
    recalculatePosition();
  }
}, [bot?.id, symbol, selectedSide, recalculatePosition]);
```

## Security Guidelines

### 1. Input Validation
```typescript
// ✅ Always validate inputs
export const createPositionWorkflow = async (
  context: PositionCreationContext
): Promise<PositionResult> => {
  // 1. Validate context first
  const validatedContext = validatePositionCreationContext(context);

  // 2. Fetch and validate trading data
  const enrichedContext = await fetchTradingData(validatedContext);

  // 3. Continue with workflow...
};
```

### 2. Authentication Checks
```typescript
// ✅ Always check authentication
export async function POST(request: NextRequest) {
  const session = await auth.api.getSession({ headers: await headers() });

  if (!session?.user?.id) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Continue with authenticated user...
}
```

This comprehensive set of cursor rules ensures consistent, maintainable, and functional code across the entire signal bot system. All new code must adhere to these patterns to maintain code quality and system reliability.
